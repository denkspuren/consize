\chapter{Warum Consize?}

\section{Die Geschichte zu Consize}

An manchen weiterführenden Schulen lernt man von Beginn an ein Instrument zu spielen. Ein beliebtes Instrument für Anfänger ist die Flöte. Warum Flöte? Das Instrument ist bei Kindern nicht unbedingt populär -- viele kennen Flöten bestenfalls aus der Weihnachtszeit. Der "`Sound"' einer Flöte strahlt nicht die unmittelbare Faszination eines rauen, schrillen Akkords auf einer E-Gitarre aus. Warum also Flöte?

Die Feinheit und Klarheit des Flötentons trainiert das Gehör. Und einen weiteren, immensen Vorteil hat die Flöte: Die bei jedem Instrument notwendige koordinative Leistung über die Hände ist reduziert auf das Wesentliche. Wer Nintendo, Playstation oder XBox spielen kann, der kann auch Löcher zuhalten -- ob er oder sie musikalisch ist oder nicht, das spielt erst einmal keine Rolle. Damit mich niemand missversteht: Eine Flöte ist kein Instrument einzig für musikdidaktische Spielchen mit Kindern. Könner trainieren über Jahre ihre Atemtechnik und Spielfertigkeit. Es bedarf der Meisterschaft, um dem Flötenspiel Leichtigkeit und Lebendigkeit abzugewinnen.

Ich habe lange nach einer "`Flöte"' für meine Informatik-Studierenden gesucht. Ich suchte nach einer Programmiersprache, die -- einer Flöte gleich -- von bestechender Einfachheit und deshalb leicht zu erlernen ist, aber nichts an Ausdrucksfähigkeit, an "`musikalischem Reichtum"' vermissen lässt.
Ich wünschte mir ein "`Programmierinstrument"', das über die Turing-Maschine hinausgeht. Die Turing-Maschine ist ein ganz primitiver Programmierapparat, der so etwas wie die Maultrommel der Informatik ist. Nett für die Effekthascherei, theoretisch von immenser Bedeutung, da im Prinzip ein vollwertiges Musikinstrument, aber aufgrund des begrenzten Tonumfangs nur wenig reizvoll im Musikalltag. Andererseits sollte die "`Programmierflöte"' einfacher sein als der Lambda-Kalkül. Der Lambda-Kalkül bildet die Grundlage fast aller funktionalen Sprachen. Lambda-Ausdrücke sind wie Orgelpfeifen, die richtig zusammengestellt und aufeinander abgestimmt eine imposante Orgel erschaffen, mit der sich gewaltige Werke orchestrieren lassen. Nicht selten glänzen funktionalen Programmierern bei Haskell, ML, Scheme oder Lisp ebenso die Augen, wie einem Musikbegeisterten die Orgelwerke von Bach in Entzückung versetzen. Zu überwältigend für Anfänger!

Wovon ich die Finger lassen wollte, das sind die imperativen, objekt-orientierten Sprachen, die überall verbreitet sind und an sehr vielen Hochschulen aufgrund ihrer Praxisrelevanz gelehrt werden. Java und C\# sind die elektronischen Keyboards mit allem nur erdenklichen Schnack. Im Zweifel muss man nur noch mit einem Finger die Tasten drücken, die gesamte Begleitband ertönt wie von selbst aus den Lautsprechern. Man kann sehr schnell beeindruckende Musikstücke hervorzaubern, ohne selbst allzu viel von Musik zu verstehen. Hier gewinnt schnell derjenige, der sich in der Bedienung der zahllosen Knöpfe auskennt. Aber wehe, man muss sich mit diesen oberflächlichen Kenntnissen in ein Orchester einfügen. Das kann gründlich daneben gehen!

Die sogenannten Skript-Sprachen, wie beispielsweise Python oder Ruby, haben einen so ursprünglichen Reiz wie Akustikgitarren -- Ruby on Rails sicher den einer E-Gitarre. Wenige Akkorde und die eigene Stimme reichen, um mitreißende Lieder zu schmettern und rührende Balladen zu trällern. Wer schaut nicht neidvoll auf die Barden, die mit den immer gleichen Akkorden so mühelos einen ganzen Abend retten und in Lagerfeuerstimmung zu tauchen vermögen? Mancher Musikkenner mag für dieses profane Können nur Verachtung übrig haben. Aber die Ruby- und Python-Programmierer sind die großen Pragmatiker, die das, was sie können, auch wirklich beherrschen und damit eine beachtliche Vielfalt an Problemen gut und zielsicher bewältigen. Das verstört die "`Keyboard-Programmierer"' bisweilen sehr. Meine Erfahrung zeigte mir aber, dass das Greifen von Akkorden auf der Gitarre nicht so leicht zu erlernen ist.

Als ich auf die Arbeiten von {\sc Manfred von Thun} und die Programmiersprache \href{http://www.latrobe.edu.au/phimvt/joy.html}{Joy} stieß, ahnte ich, bei den Blasinstrumenten angekommen zu sein. Die konzeptuelle Eleganz von Joy ist frappierend. Joy vereinfacht die Ideen, die {\sc John Backus} mit \href{http://de.wikipedia.org/wiki/Functional\_Programming\_System}{FP} schon Ende der 1970er Jahre aufgeworfen hatte. Joy wie FP sind in meinen Augen Geniestreiche. Als ich dann noch \href{http://de.wikipedia.org/wiki/Forth\_(Informatik)}{Forth} von {\sc Charles H.\ Moore} und \href{http://factorcode.org}{Factor} von {\sc Slava Pestov} entdeckte, war es um mich geschehen. Das konkatenative Programmierparadigma hatte mich in den Bann gezogen. Und meine ersten Experimente, Factor in der Lehre einzusetzen, verliefen überraschend gut.\footnote{Siehe "`\href{http://denkspuren.blogspot.de/2010/01/factor-heilbronn-university.html}{Factor @ Heilbronn University}"' im \href{http://denkspuren.blogspot.de}{denkspuren-Blog}.}

Allerdings wollte ich es noch etwas einfacher haben, so einfach wie möglich, ohne als Programmiersprache unpraktikabel zu werden. Und so beschloss ich, mir eine kleine Blockflöte an der Drehbank zu drechseln. Das Ergebnis ist Consize. Die Consize-VM (Virtuelle Maschine) besteht aus nicht einmal 150 Programmzeilen Clojure-Code; der Antriebsmotor von Factor umfasst rund 10.000 Zeilen C++-Code. Bei Consize reichen um die 500-600 Zeilen Consize-Code, um Consize selbst zu einer interaktiven Sprache zu erweitern. Bei Factor ist die Code-Basis um einiges größer und der Bootstrapping-Prozess deutlich komplizierter. Dafür ist Factor hochperformant und Consize eine lahme Ente, was für meine Einsatzzwecke jedoch unproblematisch ist.

Consize will zweierlei erreichen: Zum einen möchte ich Ihnen mit Consize aufzeigen und erläutern, wie einfach viele wichtige Programmierkonzepte der Informatik sind. Es macht einfach Spaß, sich einen Debugger mit Einzelschrittmodus in wenigen Zeilen Code zu bauen. Ebenso lässt sich ein Testwerkzeug für Unit-Tests in  10 Zeilen Consize-Code realisieren. Polymorphie und eine einfache Objekt-Orientierung mit Mehrfachvererbung sind in 20-30 Zeilen Consize-Code zu haben. Meta-Pro\-gram\-mie\-rung und der Umgang mit Continuations sind eine Fingerübung. Consize stellt sich gegen den Trend immer "`größerer"' Programmiersysteme mit mächtigen Bibliotheken und Frameworks, die in ihrem Umfang und in ihrer Vielfalt kaum mehr zu überblicken und zu beherrschen sind. Consize möchte destillieren und vereinfachen, so dass viele grundlegende Programmierkonzepte im Rahmen eines einzigen Semesters erfassbar und verstehbar sind.  

Für mich bleibt konkatenative Programmierung -- und das ist der andere Aspekt -- nicht bei den Programmierkonzepten stehen.
Ich habe mich jahrelang mit der Architektur und der Modellierung von Softwaresystemen aus der Telekommunikation beschäftigt. Telekommunikationsnetze wie auch das Internet sind Meisterwerke der (Software-)Ingenieurskunst. Bei aller Kompliziertheit dieser Netze sind die dahinter liegenden Design-Prinzipien einfach, die sich bis auf die Ebene der Software niederschlagen. Sie sind der Garant für die beachtliche Stabilität, Robustheit und Erweiterbarkeit dieser Systeme. Als ich das Buch "`\href{http://thinking-forth.sourceforge.net/}{Thinking Forth}"' von {\sc Leo Brodie} las, musste ich zu meinem großen Erstaunen feststellen, dass sich die Grundprinzipien der Programmierung konkatenativer Systeme mit den Design-Prinzipien von Kommunikationssystemen weitgehend decken. Wer konkatenativ programmiert fällt automatisch in eine softwaretechnische Denke. In konkatenativen Sprachen stellt sich eine interessante Wechselwirkung zwischen Lesbarkeit (intellektueller Nachvollziehbarkeit) eines Programms und softwaretechnischer Programmkomposition (Programmaufbau) ein -- und das schon bei kleinen Programmen. In meinen Augen kann man Softwaretechnik kaum anschaulicher und praktischer erfahrbar machen als mit konkatenativen Programmiersprachen.

Ich hoffe sehr, dass Ihnen der Umgang mit der "`Flöte"' namens Consize "`musikalische"' Grundfertigkeiten der Programmierung und der Softwaretechnik vermittelt. Sie werden eine Menge lernen. Und wie beim Flötenspiel gilt: Übung macht den Meister. Wenn Sie mit Consize das Programmierspiel verstanden haben, werden Sie sehr viel müheloser weitere Programmiersprachen erfassen und erlernen.

\section{Consize: Installation und Inbetriebnahme}

Da Consize in der Programmiersprache Clojure implementiert ist, müssen Sie zunächst Clojure installieren, siehe \href{http://clojure.org/}{clojure.org}. Die dazu notwendige Java-Laufzeitumgebung, das \emph{Java Runtime Environment} (JRE), sollten Sie zuvor auf Ihrem Rechner installiert haben. Die Consize-Im\-ple\-men\-tie\-rung \verb|consize.clj| samt der unabdingbar notwendigen Dateien \verb|prelude.txt| und \verb|bootimage.txt| werden benötigt.
% finden Sie unter \href{http://code.google.com/p/consize}{code.google.com/p/consize}.
Am einfachsten ist es, die Dateien in das Clojure-Verzeichnis zu kopieren.

Starten Sie mit \verb|cmd| eine Kommandozeile unter Windows, wechseln Sie mit \verb|cd| in das Verzeichnis, in dem sich die Clojure-Installation mit den besagten Dateien befindet, und tippen Sie Folgendes ein:

\begin{verbatim}
java -cp clojure-1.5.1.jar clojure.main consize.clj
"\ prelude.txt run say-hi"
\end{verbatim}

Aus Gründen der besseren Lesbarkeit habe ich die Zeile umgebrochen; Sie müssen alles in einer Zeile eingeben. Java wird gestartet, der Klassenpfad auf Clojure gesetzt, Clojure wird gestartet, Consize geladen und der in Anführungszeichen gesetzte Text als Startprogramm an Consize übergeben. Nach einer Weile sollte sich Consize auf der Konsole melden:

\begin{verbatim}
This is Consize -- A Concatenative Programming Language
> 
\end{verbatim}

Haben Sie inbesondere bei kleinen, langsamen Rechnern Geduld, das Laden der Prelude kann ein wenig dauern.

Sollten Sie Consize mit einem \verb|exit| beenden, kommen Sie zurück zur Ebene der Kommandozeile von Windows.

Unter Windows kann eine \href{http://de.wikipedia.org/wiki/Batchdatei}{Batchdatei} sehr hilfreich sein, um sich Tipparbeit beim Starten von Clojure zu sparen.\footnote{Siehe z.B.\ \href{http://denkspuren.blogspot.de/2011/04/clojure-per-kommandozeile-in-windows.html}{"`Clojure per Kommandozeile in Windows: CLASSPATH-Setting"'} auf dem \href{http://denkspuren.blogspot.de}{denkspuren-Blog}.}

\section{Ein Hinweis für Einsteiger}

Wenn Sie ein Neuling in der \href{http://de.wikipedia.org/wiki/Programmierung}{Programmierung} und in der \href{http://de.wikipedia.org/wiki/Informatik}{Informatik} sind, dann werden Ihnen viele Begriffe, Konzepte und Ideen fremd sein. Aus diesem Grund verweise ich an etlichen Stellen im Text auf die Einträger in der \href{http://de.wikipedia.org/wiki/Wikipedia}{Wikipedia}. 
Die Wikipedia bietet eine exzellente Möglichkeit, sich unkompliziert und in kurzer Zeit in verschiedenste Themen und Gebiete einzuarbeiten und an Wissen aufzuholen.

Die Verlinkungen im Text verweisen fast durchgängig auf die \href{http://de.wikipedia.org}{deutschsprachige Wikipedia}. Wenn Sie auf diese Weise einen Begriff nachschlagen, möchte ich Ihnen sehr ans Herz legen, auch die entsprechende englischsprachige Wikipedia-Seite zu lesen. Das Englische hat in der Informatik aus historischen Gründen eine lange Tradition. Nicht nur sollten Sie die englischsprachigen Fachbegriffe kennen, in vielen Fällen empfinde ich die englischsprachigen Wikipedia-Seiten auch als informativer und umfassender. Wenn Ihnen der Einstieg in die Informatik jedoch neu ist, dann sind meist die Wikipedia-Seiten in der eigenen Muttersprache der bessere Startpunkt. Aus diesem Grund biete ich Ihnen hauptsächlich die deutschsprachigen Wikipedia-Seiten an.

Lassen Sie sich von der Menge der Informationen nicht überfluten. Gerade am Anfang des Textes finden Sie zahlreiche Verweise in die Wikipedia, weil viele für Sie möglicherweise neue Begriffe eingeführt werden. Schon nach wenigen Seiten nimmt die Häufigkeit der Verlinkungen deutlich ab. Haben Sie Geduld mit sich, man kann nicht alles auf einmal lernen. Das Lernen geschieht mehr in Zyklen, phasenweise. Darum sollten Sie nach einer Weile Kapitel oder Textpassagen durchaus noch einmal lesen und punktuell Begriffe nachschlagen, wenn es passt. Sie werden feststellen, nach und nach beginnen die Sachen immer mehr Sinn zu machen und zusammen zu passen. Was anfangs kompliziert und unklar war, ist später, wenn Sie zu der Textstelle zurückkehren, plötzlich sonnenklar. Auch die Erläuterungen in der Wikipedia bekommen Hand und Fuß, und Sie lernen einzuordnen, was dort steht.